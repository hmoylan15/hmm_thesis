---
title: "modeling"
created: 1/17/2025
updated: 1/17/2025
output: html_document
---

### Rmarkdown Description

The purpose of this Rmarkdown is to complete modeling efforts for my thesis chapt 1. There are 4 models, they are:

Southeast Aquifers (SEAQ) - All Principal Aquifers in the Southeast US. Includes 18 aquifers: the Biscayne aquifer, Surficial aquifer system, Coastal lowlands aquifer system, Floridan aquifer system, Mississippi embayment aquifer system, Southeastern Coastal Plain aquifer system, Mississippi River Valley alluvial aquifer, Piedmont and Blue Ridge crystalline-rock aquifers, Valley and Ridge carbonate-rock aquifers, Valley and Ridge aquifers, Castle Hayne aquifer, Northern Atlantic Coastal Plain aquifer system, Mississippian aquifers, Ordovician aquifers, Pennsylvanian aquifers, Early Mesozoic basin aquifers, Silurian-Devonian aquifers, and Piedmont and Blue Ridge carbonate-rock aquifers. These 18 aquifers all have some area touching a southeastern US states (Alabama, Florida, Georgia, Mississippi, North Carolina, South Carolina, Tennessee.  

East Gulf Coastal Plain (EGCP) - The Southernmost, Sandy Alabama Physiographic Region. Includes 4 aquifers: Coastal Lowlands aquifer system, Mississippi Embayment aquifer system, Southeastern Coastal Plain aquifer system, and Surficial aquifers.  

Mississippi River Valley Alluvial Aquifer (MRVA) - An aquifer associated with high percent agricultural land use.  

Piedmont (Pied) - A crystalline-rock aquifer spanning AL - PA.  

I would like to acknowledge the use of ChatGPT, a language model developed by OpenAI in the preparation of this Rmarkdown. ChatGPT was used for code assistance and de-bugging.

### Preparation

Loading in the packages I will need.
```{r, results = "hide", message = FALSE, warning = FALSE}
library(tidyverse)
library(tidymodels)
tidymodels_prefer()
library(vip)
library(sf)
library(terra)
library(showtext)
library(doParallel)
```

### Reading and Splitting Data

Reading in the raw data (that has been imputed using the `nada2` package and has 2008, 2012, 2016, and 2020 usda crop data layer and a new septic density predictor variables) and taking log base 10 of the nitrate results.
```{r}
# raw data
rans <- read.csv("../input/processed/tt_data/tt_with_aq.csv")

rans_ready <- rans %>%
  mutate(log_NO3_results = log10(NO3_results))

# SEAQ data
seaq_data <- rans_ready

# EGCP data
egcp_data <- rans_ready %>%
  filter(AQ_CODE %in% c(201, 203, 204, 111)) # Coastal Lowlands aquifer system, Mississippi Embayment aquifer system, Southeastern Coastal Plain aquifer system, and Surficial aquifers

# MRVA data
mrva_data <- rans_ready %>%
  filter(AQ_CODE %in% 109) # Mississippi River Valley alluvial aquifer

#Pied data
pied_data <- rans_ready %>%
  filter(AQ_CODE %in% 611) # Piedmont and Blue Ridge crystalline-rock aquifers
```

Splitting the data 70/30 and stratifying by AQ_NAME.
```{r}
# seaq model
set.seed(15)
seaq_split <- initial_split(seaq_data, prop = 0.70, strata = AQ_NAME)
seaq_train <- training(seaq_split) # 9055 observations
seaq_test <- testing(seaq_split) # 3883 observations

#egcp model
set.seed(16)
egcp_split <- initial_split(egcp_data, prop = 0.70, strata = AQ_NAME)
egcp_train <- training(egcp_split) # 1901 observations
egcp_test <- testing(egcp_split) # 817 observations

# mrva model
set.seed(17)
mrva_split <- initial_split(mrva_data, prop = 0.70)
mrva_train <- training(mrva_split) # 301 observations
mrva_test <- testing(mrva_split) # 130 observations

# pied model
set.seed(18)
pied_split <- initial_split(pied_data, prop = 0.70)
pied_train <- training(pied_split) # 1314 observations
pied_test <- testing(pied_split) # 564 observations
```

### Creating Workflows

Setting model specifications.
```{r}
# defining the model
rf_spec <- 
  rand_forest(mtry = 50, trees = tune(), min_n = tune()) %>%
  set_mode("regression") %>%
  set_engine("ranger")

# setting the range for each parameter to be tuned
params <- parameters(
  trees(range = c(500, 2000)),
  min_n(range = c(2, 25))
)
```

Creating the recipes and workflows for each model.
```{r}
# seaq recipe
seaq_rf_rec <-
  recipe(log_NO3_results ~ ., data = seaq_train) %>%
  step_rm(AQ_CODE, AQ_NAME, Join_Count, TARGET_FID, Field1, SITE_NO, year, DEC_LAT_VA, DEC_LONG_VA, DEPTH, NO3_results) %>%
  step_nzv()

# seaq workflow
seaq_rf_wflow <- 
  workflow() %>%
  add_recipe(seaq_rf_rec) %>%
  add_model(rf_spec)

# egcp recipe
egcp_rf_rec <-
  recipe(log_NO3_results ~ ., data = egcp_train) %>%
  step_rm(AQ_CODE, AQ_NAME, Join_Count, TARGET_FID, Field1, SITE_NO, year, DEC_LAT_VA, DEC_LONG_VA, DEPTH, NO3_results) %>%
  step_nzv()

# egcp workflow
egcp_rf_wflow <- 
  workflow() %>%
  add_recipe(egcp_rf_rec) %>%
  add_model(rf_spec)

# mrva recipe
mrva_rf_rec <-
  recipe(log_NO3_results ~ ., data = mrva_train) %>%
  step_rm(AQ_CODE, AQ_NAME, Join_Count, TARGET_FID, Field1, SITE_NO, year, DEC_LAT_VA, DEC_LONG_VA, DEPTH, NO3_results) %>%
  step_nzv()

# mrva workflow
mrva_rf_wflow <- 
  workflow() %>%
  add_recipe(mrva_rf_rec) %>%
  add_model(rf_spec)

# pied recipe
pied_rf_rec <-
  recipe(log_NO3_results ~ ., data = pied_train) %>%
  step_rm(AQ_CODE, AQ_NAME, Join_Count, TARGET_FID, Field1, SITE_NO, year, DEC_LAT_VA, DEC_LONG_VA, DEPTH, NO3_results) %>%
  step_nzv()

# pied workflow
pied_rf_wflow <- 
  workflow() %>%
  add_recipe(pied_rf_rec) %>%
  add_model(rf_spec)
```

Tuning seaq model.
```{r}
# establishing cross-validation splits
set.seed(19)
seaq_splits <- vfold_cv(seaq_train, v = 5, strata = AQ_NAME)

rf_grid <- dials::grid_random(params, size = 10)

cl <- makePSOCKcluster(parallel::detectCores() - 1)
registerDoParallel(cl)

set.seed(20)
seaq_rf_tuned <- tune_grid(
  seaq_rf_wflow,
  resamples = seaq_splits,
  grid = rf_grid,
  metrics = metric_set(rmse, rsq),
  control = control_grid(
    save_pred = TRUE,
    verbose = TRUE
  )
)

stopCluster(cl)

seaq_tune_metrics <- collect_metrics(seaq_rf_tuned)
```

Tuning egcp model.
```{r}
# establishing cross-validation splits
set.seed(21)
egcp_splits <- vfold_cv(egcp_train, v = 5, strata = AQ_NAME)

rf_grid <- dials::grid_random(params, size = 10)

cl <- makePSOCKcluster(parallel::detectCores() - 1)
registerDoParallel(cl)

set.seed(22)
egcp_rf_tuned <- tune_grid(
  egcp_rf_wflow,
  resamples = egcp_splits,
  grid = rf_grid,
  metrics = metric_set(rmse, rsq),
  control = control_grid(
    save_pred = TRUE,
    verbose = TRUE
  )
)

stopCluster(cl)

egcp_tune_metrics <- collect_metrics(egcp_rf_tuned)
```

Tuning mrva model.
```{r}
# establishing cross-validation splits
set.seed(23)
mrva_splits <- vfold_cv(mrva_train, v = 5)

rf_grid <- dials::grid_random(params, size = 10)

cl <- makePSOCKcluster(parallel::detectCores() - 1)
registerDoParallel(cl)

set.seed(24)
mrva_rf_tuned <- tune_grid(
  mrva_rf_wflow,
  resamples = mrva_splits,
  grid = rf_grid,
  metrics = metric_set(rmse, rsq),
  control = control_grid(
    save_pred = TRUE,
    verbose = TRUE
  )
)

stopCluster(cl)

mrva_tune_metrics <- collect_metrics(mrva_rf_tuned)

mrva_tune_metrics
```

Tuning pied model.
```{r}
# establishing cross-validation splits
set.seed(25)
pied_splits <- vfold_cv(pied_train, v = 5, strata = AQ_NAME)

rf_grid <- dials::grid_random(params, size = 10)

cl <- makePSOCKcluster(parallel::detectCores() - 1)
registerDoParallel(cl)

set.seed(26)
pied_rf_tuned <- tune_grid(
  pied_rf_wflow,
  resamples = pied_splits,
  grid = rf_grid,
  metrics = metric_set(rmse, rsq),
  control = control_grid(
    save_pred = TRUE,
    verbose = TRUE
  )
)

stopCluster(cl)

pied_tune_metrics <- collect_metrics(pied_rf_tuned)
```














